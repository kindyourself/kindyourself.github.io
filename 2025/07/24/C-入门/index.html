<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <!-- 添加全局禁用 Referer -->
      <meta name="referrer" content="no-referrer" />
      <meta charset="utf-8" />
       
      <meta name="keywords" content="技术,编程,开发,Hexo" />
       
      <meta name="description" content="个人技术博客，分享编程、开发经验和生活感悟" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>C++ 基础入门 |  Gavin&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
      <!-- Font Awesome 6 -->
<link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
      integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer" />
    <link rel="alternate" href="/atom.xml" title="Gavin's Blog" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="[layout]-C-入门"
  class="article article-type-[layout]"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  C++ 基础入门
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/07/24/C-%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2025-07-24T10:55:07.000Z" itemprop="datePublished">2025-07-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">14.9k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">66 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>C++ 是一种广泛使用的、面向对象的、通用的编程语言，它在系统&#x2F;应用软件开发、游戏开发、嵌入式系统等领域有着广泛的应用。对于初学者来说，掌握 C++ 的基础知识和核心概念是学习编程的重要一步</p>
</blockquote>
<h1 id="1-C-的历史与特点"><a href="#1-C-的历史与特点" class="headerlink" title="1. C++ 的历史与特点"></a>1. C++ 的历史与特点</h1><blockquote>
<p>C++ 由 <code>Bjarne Stroustrup</code> 在 1985 年开发，最初是作为 C 语言的扩展，后来发展成为一种支持面向对象编程（<code>OOP</code>）的语言。C++ 保留了 C 语言的大部分特性，同时增加了类、继承、多态等 <code>OOP</code> 的核心概念，使得它在处理大型程序时更加高效和灵活</p>
</blockquote>
<h3 id="主要特点包括："><a href="#主要特点包括：" class="headerlink" title="主要特点包括："></a>主要特点包括：</h3><blockquote>
<p><strong>灵活性：</strong> C++ 支持多种编程范式，包括过程化编程、面向对象编程和泛型编程。开发者可以根据需要选择合适的编程风格，使程序设计更加灵活和多样化</p>
<p><strong>面向对象编程（OOP）：</strong> C++ 支持类和对象的概念，通过封装、继承和多态等机制实现面向对象编程。这种编程方式提高了代码的复用性和可维护性，使程序结构更加清晰和模块化</p>
<p><strong>泛型编程：</strong> C++ 引入了模板机制，允许开发者编写通用的代码，从而提高代码的复用性和灵活性。标准模板库（<code>STL</code>）提供了丰富的容器、算法和迭代器，简化了常见的数据结构和操作</p>
<p><strong>高性能：</strong> C++ 是一种编译型语言，可以直接生成高效的机器码，适合开发对性能要求极高的应用。它继承了 C 语言的高效特性，程序运行速度快，执行效率高</p>
<p><strong>内存管理：</strong> C++ 提供了对内存的直接控制，开发者可以手动管理内存，但也需要谨慎处理以避免内存泄漏等问题。C++ 还支持智能指针和 RAII 技术，提高了内存管理的安全性</p>
<p><strong>可移植性：</strong> C++ 源代码可以在不同平台上编译、链接和运行，无需为每个平台单独编写代码，节省时间和精力。C++ 的可移植性使其成为跨平台开发的理想选择</p>
<p><strong>强类型检查：</strong> C++ 是一种静态类型语言，在编译时进行类型检查，提高代码的安全性和效率。这种类型检查机制有助于在编译阶段发现潜在的错误，提高程序的健壮性</p>
<p><strong>标准库支持：</strong> C++ 标准库（ <code>Standard Template Library</code> ， <code>STL</code> ）提供了大量的容器、算法和迭代器，方便开发者进行高效的编程。这些库函数涵盖了从数据结构到算法实现的各个方面，极大地提高了开发效率</p>
<p><strong>多线程支持：</strong> 自 C++11 起，C++ 引入了线程库，便于多线程编程，实现并发执行和任务分配。多线程支持使得 C++ 能够更好地利用现代多核处理器的性能</p>
<p><strong>兼容性：</strong> C++ 保持了与 C 语言的兼容性，绝大多数 C 语言程序可以不经修改直接在 C++ 环境中运行。这种兼容性使得 C++ 成为一种灵活的编程语言，能够无缝集成现有的 C 语言代码</p>
<p><strong>指针：</strong> C++ 支持指针功能，可以直接与内存交互，用于内存、结构和数组等。指针提供了对内存的直接访问能力，增强了程序的灵活性和效率</p>
<p><strong>模块化：</strong> C++ 允许使用函数将程序分解为部分，便于理解和修改。模块化设计使得程序结构更加清晰，便于维护和扩展</p>
</blockquote>
<h1 id="2-C-的基本结构"><a href="#2-C-的基本结构" class="headerlink" title="2. C++ 的基本结构"></a>2. C++ 的基本结构</h1><blockquote>
<p>C++ 的基本结构是构成程序的基础，它决定了程序的组织方式和执行流程</p>
</blockquote>
<h3 id="C-程序通常包含以下几个部分"><a href="#C-程序通常包含以下几个部分" class="headerlink" title="C++ 程序通常包含以下几个部分"></a>C++ 程序通常包含以下几个部分</h3><blockquote>
<p><strong>预处理指令：</strong> 如 <code>#include &lt;iostream&gt;</code> ，用于引入头文件</p>
</blockquote>
<blockquote>
<p><strong>命名空间：</strong> 不同库或模块中相同标识符（如变量、函数名）可通过命名空间隔离，命名空间类似于操作系统中的目录和文件的关系，用于避免命名冲突，命名空间通过 <code>namespace</code> 关键字定义，在命名空间外部，可以通过使用每个标识符的完整名称或 <code>using</code> 声明来访问其成员</p>
</blockquote>
<p><strong>1. using 声明（引入特定成员）</strong></p>
<p><strong>2.	using namespace 指令（引入整个空间，慎用）</strong></p>
<p><strong>3. 头文件中禁止使用 using namespace，防止包含时扩散冲突</strong></p>
<p><strong>4. 避免全局污染：优先使用显式限定（Namespace::member）或 using 声明（非 using namespace）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">namespace First &#123;</span><br><span class="line">    void sayHello() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Hello First Namespace&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace Second &#123;</span><br><span class="line">    void sayHello() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Hello Second Namespace&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    First::sayHello();</span><br><span class="line">    Second::sayHello();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>嵌套命名空间</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">namespace Outer &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line">    namespace Inner &#123;</span><br><span class="line">        int y = 20;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; Outer::x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; Outer::Inner::y &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>主函数：</strong> <code>int main()</code> 是程序的入口点</p>
</blockquote>
<blockquote>
<p><strong>输出语句：</strong> 如 <code>std::cout &lt;&lt; &quot;Hello, World!&quot;; </code>，用于输出信息</p>
</blockquote>
<blockquote>
<p><strong>返回值：</strong> <code>return 0; </code> 表示程序正常结束</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>输出：Hello, World!</code></p>
<h1 id="3-C-的基本语法"><a href="#3-C-的基本语法" class="headerlink" title="3. C++ 的基本语法"></a>3. C++ 的基本语法</h1><blockquote>
<p>C++ 的语法与 C 语言非常相似，但有一些扩展和改进</p>
</blockquote>
<h2 id="C-的一些基本语法元素"><a href="#C-的一些基本语法元素" class="headerlink" title="C++ 的一些基本语法元素"></a>C++ 的一些基本语法元素</h2><h3 id="1-变量声明"><a href="#1-变量声明" class="headerlink" title="1. 变量声明"></a>1. 变量声明</h3><blockquote>
<p>想要使用变量，必须先做 <code>声明</code>，同时还要指明保存数据所需要的空间大小，使用 <code>int</code> , <code>float</code> , <code>bool</code> , <code>char</code> 等关键字声明变量</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a; // 声明</span><br><span class="line">a = 1; // 赋值操作</span><br><span class="line">int a = 1; // 声明且赋值操作</span><br><span class="line">a = 2; // 修改变量值</span><br></pre></td></tr></table></figure>

<h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h3><blockquote>
<p>C++ 提供了多种基本数据类型，如 <code>int</code> , <code>float</code> , <code>double</code> , <code>bool</code> , <code>char</code> 等，使用 <code>sizeof()</code> 运算符可获取类型或变量占用的字节数</p>
</blockquote>
<h4 id="一、基本数据类型"><a href="#一、基本数据类型" class="headerlink" title="一、基本数据类型"></a>一、基本数据类型</h4><blockquote>
<p><strong>整数类型：</strong> 用于表示整数值，包括 <code>int</code> 、<code>short</code> 、<code>long</code> 、<code>long long</code> 以及它们的无符号版本 <code>unsigned int</code> 、<code>unsigned short</code> 、<code>unsigned long</code> 、<code>unsigned long long</code> 。这些类型用于存储整数数据，其范围和精度取决于具体类型。例如，<code>int</code> 通常占用 4 个字节，而 <code>short</code> 通常占用 2 个字节 </p>
<p><strong>浮点类型：</strong> 用于表示实数，包括 <code>float</code> 、<code>double</code> 和 <code>long double</code> 。<code>float</code> 通常占用 4 个字节，可以存储 7 位小数；<code>double</code> 通常占用 8 个字节，可以存储 15 位小数；<code>long double</code> 通常占用 16 个字节，精度更高 </p>
<p><strong>字符类型：</strong> 用于表示单个字符，包括 <code>char</code> 和 <code>wchar_t</code> 。<code>char</code> 通常占用 1 个字节，而 <code>wchar_t</code> 用于表示宽字符，但其大小由实现定义，不可靠 </p>
<p><strong>布尔类型：</strong> 用于表示布尔值，即 <code>true</code> 或 <code>false</code>，通常占用 1 个字节 </p>
<p><strong>空类型：</strong> 表示没有值或没有返回值，常用于函数返回值或指针，如 <code>void*</code></p>
</blockquote>
<h4 id="二、用户自定义数据类型"><a href="#二、用户自定义数据类型" class="headerlink" title="二、用户自定义数据类型"></a>二、用户自定义数据类型</h4><p><strong>结构体（struct）</strong></p>
<blockquote>
<p>结构体用于封装多个不同类型的成员变量，从而形成一个逻辑上相关的数据集合，C++中 <code>struct</code> 可包含构造函数、析构函数、继承和多态，功能与 <code>class</code> 几乎相同，仅默认权限不同，结构体成员默认为公有（<code>public</code>），结构体的成员可以通过点运算符（.）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体名称 &#123;</span><br><span class="line">    数据类型 成员1;</span><br><span class="line">    数据类型 成员2;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">    // 数据成员</span><br><span class="line">    int id;</span><br><span class="line">    std::string name;</span><br><span class="line">    double score;</span><br><span class="line">    </span><br><span class="line">    Student(int a, std::string b, double c) : id(a), name(b), score(c), &#123;&#125;  // 自定义构造函数 </span><br><span class="line">    </span><br><span class="line">    // 成员函数（C++支持）</span><br><span class="line">    void printInfo() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; id &lt;&lt; &quot;, Name: &quot; &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student p1(10, &quot;Alice&quot;, 1.5);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; p1.id &lt;&lt; &quot;, Name: &quot; &lt;&lt; p1.name &lt;&lt; &quot;, Score: &quot; &lt;&lt; p1.score &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">// 2. 创建一个学生对象</span><br><span class="line">// 注意：这里使用了一个简单的构造函数来初始化学生对象</span><br><span class="line">Student s1 = &#123;101, &quot;Alice&quot;, 95.5&#125;; // C++11起支持</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; s1.id &lt;&lt; &quot;, Name: &quot; &lt;&lt; s1.name &lt;&lt; &quot;, Score: &quot; &lt;&lt; s1.score &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">ID: 10, Name: Alice, Score: 1.5</span><br><span class="line">ID: 101, Name: Alice, Score: 95.5</span><br></pre></td></tr></table></figure>

<p><strong>联合（union）</strong></p>
<blockquote>
<p> 联合用于存储多个数据元素，但这些元素共享同一内存位置，因此只能同时存储一个元素</p>
</blockquote>
<ol>
<li><p>联合的大小等于其成员中最大的成员的大小</p>
</li>
<li><p>联合不能作为基类使用，因为它不能继承自其他类</p>
</li>
<li><p>联合不能包含引用类型的成员，因为引用需要额外的存储空间</p>
</li>
<li><p>匿名联合不使用点运算符，其成员必须是数据类型，不允许有成员函数或私有&#x2F;受保护的成员，为了防止访问错误</p>
</li>
<li><p>建议在联合中定义一个额外的对象（判别式）来跟踪当前存储的值的类型</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Token &#123;</span><br><span class="line">public:</span><br><span class="line">    enum TokenKind &#123; INT, CHAR, DBL &#125;;</span><br><span class="line">    TokenKind tok;</span><br><span class="line">    union &#123;</span><br><span class="line">        char cval;</span><br><span class="line">        int ival;</span><br><span class="line">        double dval;</span><br><span class="line">    &#125; val;</span><br><span class="line">    </span><br><span class="line">    void print() &#123;</span><br><span class="line">        switch (tok) &#123;</span><br><span class="line">            case INT:</span><br><span class="line">                cout &lt;&lt; &quot;Integer: &quot; &lt;&lt; val.ival &lt;&lt; endl;</span><br><span class="line">                break;</span><br><span class="line">            case CHAR:</span><br><span class="line">                cout &lt;&lt; &quot;Character: &quot; &lt;&lt; val.cval &lt;&lt; endl;</span><br><span class="line">                break;</span><br><span class="line">            case DBL:</span><br><span class="line">                cout &lt;&lt; &quot;Double: &quot; &lt;&lt; val.dval &lt;&lt; endl;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Token token;</span><br><span class="line">    </span><br><span class="line">    token.tok = Token::INT;</span><br><span class="line">    token.val.ival = 42;</span><br><span class="line">    token.print();</span><br><span class="line">    </span><br><span class="line">    token.tok = Token::CHAR;</span><br><span class="line">    token.val.cval = &#x27;a&#x27;;</span><br><span class="line">    token.print();</span><br><span class="line">    </span><br><span class="line">    token.tok = Token::DBL;</span><br><span class="line">    token.val.dval = 3.1416;</span><br><span class="line">    token.print();</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>枚举（enum）</strong></p>
<blockquote>
<p>枚举用于定义一组命名的常量，枚举成员默认从 0 开始递增，也可以显式指定值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum class WeekDay &#123;</span><br><span class="line">    Sunday,</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">WeekDay today = WeekDay::Wednesday; // 成员需通过枚举名::访问，避免命名冲突</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum RGB &#123;</span><br><span class="line">    R = 2,</span><br><span class="line">    G,</span><br><span class="line">    B = 5</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">G的值为R+1，结果为3</span><br></pre></td></tr></table></figure>

<p><strong>类（class）</strong></p>
<blockquote>
<p> 类用于创建类实例，包含成员函数和数据成员，是 C++ 面向对象编程的核心</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ClassName &#123;</span><br><span class="line">public:    // 公共成员（外部可访问）</span><br><span class="line">// 构造函数 </span><br><span class="line">ClassName(参数列表) &#123; ... &#125;  </span><br><span class="line"></span><br><span class="line">// 成员函数 </span><br><span class="line">void memberFunc() &#123; ... &#125;  </span><br><span class="line"></span><br><span class="line">protected: // 受保护成员（仅子类及自身可访问）</span><br><span class="line">    int protectedVar;</span><br><span class="line">    </span><br><span class="line">private:   // 私有成员（仅自身可访问）</span><br><span class="line">    int privateVar;</span><br><span class="line">    </span><br><span class="line">&#125;; // 注意分号不可省略</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 类定义</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    void setName(const std::string&amp; name);</span><br><span class="line">    std::string getName() const;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 成员函数的实现</span><br><span class="line">void Person::setName(const std::string&amp; name) &#123;</span><br><span class="line">    this-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string Person::getName() const &#123;</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、派生数据类型"><a href="#三、派生数据类型" class="headerlink" title="三、派生数据类型"></a>三、派生数据类型</h4><p><code>派生数据类型是从基本数据类型或用户定义数据类型衍生出来的数据类型</code></p>
<p><strong>数组</strong> </p>
<blockquote>
<p>数组用于存储固定大小、相同类型元素的连续内存集合，编译时确定大小，不可动态扩展，数组索引从 0 开始，支持多维数组，内存连续性：元素物理地址相邻，支持高效随机访问</p>
</blockquote>
<p><strong><code>声明方式</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 一维数组 </span><br><span class="line">int arr1[5]();          // 未初始化，值为随机数 </span><br><span class="line">int arr2[5]() = &#123;1, 2&#125;; // 部分初始化，剩余元素自动补0 → &#123;1,2,0,0,0&#125;</span><br><span class="line">int arr3[] = &#123;1,2,3&#125;; // 自动推断大小为3</span><br><span class="line"></span><br><span class="line">// 二维数组（数组的数组）</span><br><span class="line">int matrix[2][3] = &#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;&#125;; // 标准初始化</span><br><span class="line">int matrix2[][2] = &#123;1,2,3,4&#125;;           // 省略行数，自动推断为2行 </span><br></pre></td></tr></table></figure>

<p><strong><code>遍历方式</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int arr[5]()  = &#123;10,20,30,40,50&#125;;</span><br><span class="line">// 1. for循环（推荐控制索引范围）</span><br><span class="line">for(int i=0; i&lt;5; i++) cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line"> </span><br><span class="line">// 2. 范围for循环（C++11）</span><br><span class="line">for(int num : arr) cout &lt;&lt; num &lt;&lt; &quot; &quot;;</span><br><span class="line"> </span><br><span class="line">// 3. 指针遍历 </span><br><span class="line">int *p = arr;</span><br><span class="line">while(p &lt; arr + 5) cout &lt;&lt; *p++ &lt;&lt; &quot; &quot;;</span><br></pre></td></tr></table></figure>

<p><strong><code>多维数组操作</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int matrix[2]()[3]() = &#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;&#125;;</span><br><span class="line">// 嵌套循环遍历 </span><br><span class="line">for(int i=0; i&lt;2; i++) &#123;</span><br><span class="line">    for(int j=0; j&lt;3; j++) &#123;</span><br><span class="line">        cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 内存按行连续存储：matrix[0][3] 等价于 matrix[1]()[0]()</span><br></pre></td></tr></table></figure>

<p><strong>指针</strong> </p>
<blockquote>
<p>指针用于存储变量的地址，它允许程序员直接访问和操作内存地址，通过指针，可以实现对内存的灵活管理、动态分配、数组操作、函数调用等高级功能</p>
</blockquote>
<p><strong><code>获取地址与解引用</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int num = 10;</span><br><span class="line">int *ptr = &amp;num; // ptr 指向 num 的地址</span><br><span class="line">cout &lt;&lt; *ptr; // 输出 10</span><br></pre></td></tr></table></figure>

<p><strong><code>空指针与野指针</code></strong></p>
<blockquote>
<p><code>空指针（null pointer）</code> 通常用 nullptr（C++11 引入）或 NULL 表示，表示没有指向任何有效内存地址。<code>野指针（dangling pointer）</code> 是指指向已释放内存的指针，访问野指针会导致未定义行为，预防：指针释放后置为NULL（delete p; p &#x3D; NULL;），避免再次使用</p>
</blockquote>
<p><strong><code>动态内存分配</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int *pn = new int; // 分配一个整数的内存</span><br><span class="line">int *psome = new int[20]; // 分配 20 个整数的内存</span><br><span class="line"></span><br><span class="line">delete pn; // 使用 delete 释放内存</span><br><span class="line">delete[] psome;</span><br></pre></td></tr></table></figure>

<p><strong><code>指针运算</code></strong> </p>
<blockquote>
<p>指针可以进行算术运算，如加减操作，但需注意基于指针指向的数据类型大小</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int arr[5] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int *p = arr;</span><br><span class="line">p++; // 指向下一个元素</span><br></pre></td></tr></table></figure>

<p><strong><code>指针与数组</code></strong></p>
<blockquote>
<p>数组名在大多数情况下被视为指向数组首元素的指针，但数组和指针本质不同。数组名没有自己的存储空间，而指针有自己的存储空间</p>
</blockquote>
<p><strong><code>指针作为函数参数</code></strong></p>
<blockquote>
<p>将指针作为函数参数传递时，函数内对指针所指向变量的修改将影响原始变量</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void increment(int *p) &#123;</span><br><span class="line">    (*p)++;</span><br><span class="line">&#125;</span><br><span class="line">int num = 10;</span><br><span class="line">increment(&amp;num); // num 变为 11</span><br></pre></td></tr></table></figure>

<p><strong><code>智能指针</code></strong></p>
<blockquote>
<p>智能指针是C++标准库（ <code>&lt;memory&gt;</code> 头文件）提供的自动内存管理工具，通过 <code>RAII</code>（资源获取即初始化）机制，将动态分配的内存（堆内存）封装为对象，在智能指针生命周期结束时自动释放所管理的内存，C++智能指针是现代C++内存管理的核心工具，正确使用它们可以大幅提升代码的安全性和可维护性，解决了手动管理内存的两大痛点：</p>
</blockquote>
<p><code>内存泄漏（忘记delete）</code></p>
<p><code>悬空指针（对象已释放但指针仍被使用）</code></p>
<blockquote>
<p><strong>unique_ptr：</strong> 用于独占所有权的场景（如管理局部动态对象、避免拷贝）</p>
<p><strong>shared_ptr：</strong> 用于共享所有权的场景（如多个对象共享同一资源）</p>
<p><strong>weak_ptr：</strong> 用于解决 <code>shared_ptr</code> 循环引用的问题（如观察者模式、缓存）</p>
</blockquote>
<p><strong><code>创建</code></strong></p>
<blockquote>
<p><strong>unique_ptr：</strong> 独占所有权的智能指针，同一时间只能有一个 <code>unique_ptr</code> 指向同一个对象，禁止拷贝（<code>copy constructor</code> 和 <code>operator</code> 被删除），但允许移动（<code>move constructor</code> 和 <code>move operator</code> 有效，优先使用 <code>std::make_unique</code> （C++14引入），它更简洁、异常安全（避免 <code>new</code> 后构造函数抛出异常导致内存泄漏），当 <code>unique_ptr</code> 超出作用域或被 <code>reset()</code> 时，自动调用 <code>delete</code> 释放所管理的内存（若管理数组，则调用 <code>delete[]</code> ）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">class Test &#123; </span><br><span class="line">public:</span><br><span class="line">    Test(int id) : id_(id) &#123; std::cout &lt;&lt; &quot;Test &quot; &lt;&lt; id_ &lt;&lt; &quot; constructed.\n&quot;; &#125; </span><br><span class="line">    ~Test() &#123; std::cout &lt;&lt; &quot;Test &quot; &lt;&lt; id_ &lt;&lt; &quot; destructed.\n&quot;; &#125; </span><br><span class="line">    void show() &#123; std::cout &lt;&lt; &quot;Test &quot; &lt;&lt; id_ &lt;&lt; &quot; is alive.\n&quot;; &#125; </span><br><span class="line">private:</span><br><span class="line">    int id_; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">int main() &#123; </span><br><span class="line">    // 方式1：用make_unique创建（推荐）</span><br><span class="line">    std::unique_ptr&lt;Test&gt; up1 = std::make_unique&lt;Test&gt;(1); </span><br><span class="line">    up1-&gt;show(); // 访问对象成员 </span><br><span class="line"> </span><br><span class="line">    // 方式2：用new直接构造（不推荐，除非需要自定义删除器） </span><br><span class="line">    std::unique_ptr&lt;Test&gt; up2(new Test(2)); </span><br><span class="line">    up2-&gt;show(); </span><br><span class="line"> </span><br><span class="line">    return; // up1、up2超出作用域，自动析构Test对象 </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Test 1 constructed</span><br><span class="line"></span><br><span class="line">Test 1 is alive</span><br><span class="line"></span><br><span class="line">Test 2 constructed</span><br><span class="line"></span><br><span class="line">Test 2 is alive</span><br><span class="line"></span><br><span class="line">Test 2 destructed</span><br><span class="line"></span><br><span class="line">Test 1 destructed</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>shared_ptr：</strong> 共享所有权的智能指针，多个 <code>shared_ptr </code>可以指向同一个对象，通过引用计数（ <code>reference count</code> ）跟踪对象的被引用次数，当最后一个 <code>shared_ptr</code> 析构或 <code>reset()</code> 时，引用计数变为0，自动释放对象内存，引用计数的修改是原子操作（线程安全），但对象本身的访问需要手动同步（如用 <code>mutex</code> ）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">class Test &#123; </span><br><span class="line">public:</span><br><span class="line">    Test(int id) : id_(id) &#123; std::cout &lt;&lt; &quot;Test &quot; &lt;&lt; id_ &lt;&lt; &quot; constructed.\n&quot;; &#125; </span><br><span class="line">    ~Test() &#123; std::cout &lt;&lt; &quot;Test &quot; &lt;&lt; id_ &lt;&lt; &quot; destructed.\n&quot;; &#125; </span><br><span class="line">    void show() &#123; std::cout &lt;&lt; &quot;Test &quot; &lt;&lt; id_ &lt;&lt; &quot; is alive.\n&quot;; &#125; </span><br><span class="line">private:</span><br><span class="line">    int id_; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">int main() &#123; </span><br><span class="line">    // 方式1：用make_shared创建（推荐）</span><br><span class="line">    std::shared_ptr&lt;Test&gt; sp1 = std::make_shared&lt;Test&gt;(1); </span><br><span class="line">    std::cout &lt;&lt; &quot;sp1 use count: &quot; &lt;&lt; sp1.use_count()  &lt;&lt; &quot;\n&quot;; // 引用计数：1 </span><br><span class="line"> </span><br><span class="line">    // 方式2：用new直接构造（不推荐）</span><br><span class="line">    std::shared_ptr&lt;Test&gt; sp2(new Test(2)); </span><br><span class="line">    std::cout &lt;&lt; &quot;sp2 use count: &quot; &lt;&lt; sp2.use_count()  &lt;&lt; &quot;\n&quot;; // 引用计数：1 </span><br><span class="line"> </span><br><span class="line">    // 拷贝shared_ptr，引用计数增加 </span><br><span class="line">    std::shared_ptr&lt;Test&gt; sp3 = sp1; </span><br><span class="line">    std::cout &lt;&lt; &quot;sp1 use count after copy: &quot; &lt;&lt; sp1.use_count()  &lt;&lt; &quot;\n&quot;; // 引用计数：2 </span><br><span class="line"> </span><br><span class="line">    return; // sp1、sp2、sp3析构，引用计数变为0，自动释放对象 </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">Test 1 constructed</span><br><span class="line"></span><br><span class="line">sp1 use count: 1</span><br><span class="line"></span><br><span class="line">Test 2 constructed</span><br><span class="line"></span><br><span class="line">sp2 use count: 1</span><br><span class="line"></span><br><span class="line">sp1 use count after copy: 2</span><br><span class="line"></span><br><span class="line">Test 2 destructed</span><br><span class="line"></span><br><span class="line">Test 1 destructed</span><br></pre></td></tr></table></figure>

<p><strong><code>移动所有权</code></strong></p>
<blockquote>
<p> <strong>unique_ptr：</strong> 不能拷贝，但可以通过 <code>std::move</code> 转移所有权（原 <code>unique_ptr</code> 变为 <code>nullptr </code>）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;Test&gt; up1 = std::make_unique&lt;Test&gt;(1); </span><br><span class="line">std::unique_ptr&lt;Test&gt; up2 = std::move(up1); // 转移所有权，up1变为nullptr </span><br><span class="line"> </span><br><span class="line">if (up1 == nullptr) &#123; </span><br><span class="line">    std::cout &lt;&lt; &quot;up1 is null.\n&quot;; </span><br><span class="line">&#125; </span><br><span class="line">up2-&gt;show(); // up2拥有对象所有权 </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Test 1 constructed</span><br><span class="line"></span><br><span class="line">up1 is null</span><br><span class="line"></span><br><span class="line">Test 1 is alive</span><br><span class="line"></span><br><span class="line">Test 1 destructed</span><br></pre></td></tr></table></figure>

<p><strong><code>管理动态数组</code></strong></p>
<blockquote>
<p><strong>unique_ptr：</strong> 支持管理动态数组，需指定数组类型（<code>T[]</code>），此时会自动调用 <code>delete[] </code>释放内存</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;int[]&gt; up_arr = std::make_unique&lt;int[]&gt;(5); // 创建5个int的数组 </span><br><span class="line">for (int i = 0; i &lt; 5; ++i) &#123; </span><br><span class="line">    up_arr[i] = i + 1; // 像普通数组一样访问 </span><br><span class="line">    std::cout &lt;&lt; up_arr[i] &lt;&lt; &quot; &quot;; </span><br><span class="line">&#125; </span><br><span class="line">std::cout &lt;&lt; &quot;\n&quot;; </span><br><span class="line">// 超出作用域时，自动释放数组（delete[]） </span><br></pre></td></tr></table></figure>

<p><strong><code>引用计数操作</code></strong></p>
<blockquote>
<p><strong>shared_ptr：</strong><br><code>use_count()</code>：返回当前引用计数（仅用于调试，不要依赖其值做逻辑判断）<br><code>reset()</code>：重置 <code>shared_ptr</code>，引用计数减少（若指定新对象，则指向新对象）<br><code>get()</code>：返回裸指针（需谨慎使用，避免悬空指针）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Test&gt; sp1 = std::make_shared&lt;Test&gt;(1); </span><br><span class="line">std::shared_ptr&lt;Test&gt; sp2 = sp1; </span><br><span class="line">std::cout &lt;&lt; &quot;sp1 use count: &quot; &lt;&lt; sp1.use_count()  &lt;&lt; &quot;\n&quot;; // 2 </span><br><span class="line"> </span><br><span class="line">sp2.reset();  // sp2重置，引用计数减少到1 </span><br><span class="line">std::cout &lt;&lt; &quot;sp1 use count after reset sp2: &quot; &lt;&lt; sp1.use_count()  &lt;&lt; &quot;\n&quot;; // 1 </span><br><span class="line"> </span><br><span class="line">sp1.reset(new  Test(2)); // sp1指向新对象，原对象引用计数变为0，自动释放 </span><br><span class="line">std::cout &lt;&lt; &quot;sp1 use count after reset to new object: &quot; &lt;&lt; sp1.use_count()  &lt;&lt; &quot;\n&quot;; // 1 </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Test 1 constructed</span><br><span class="line"></span><br><span class="line">sp1 use count: 2</span><br><span class="line"></span><br><span class="line">sp1 use count after reset sp2: 1 </span><br><span class="line"></span><br><span class="line">Test 1 destructed</span><br><span class="line"></span><br><span class="line">Test 2 constructed</span><br><span class="line"></span><br><span class="line">sp1 use count after reset to new object: 1</span><br><span class="line"></span><br><span class="line">Test 2 destructed</span><br></pre></td></tr></table></figure>

<p><strong><code>循环引用问题</code></strong></p>
<blockquote>
<p><strong>shared_ptr：</strong> 当两个 <code>shared_ptr</code> 互相引用时，会导致引用计数永远不为0，内存无法释放（内存泄漏）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">struct A &#123; </span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr;</span><br><span class="line">    ~A() &#123; std::cout &lt;&lt; &quot;A destructed.\n&quot;; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">struct B &#123; </span><br><span class="line">    std::shared_ptr&lt;A&gt; a_ptr;</span><br><span class="line">    ~B() &#123; std::cout &lt;&lt; &quot;B destructed.\n&quot;; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">int main() &#123; </span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;(); </span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;(); </span><br><span class="line">    a-&gt;b_ptr = b; // A引用B</span><br><span class="line">    b-&gt;a_ptr = a; // B引用A（循环引用）</span><br><span class="line"> </span><br><span class="line">    // a和b析构时，引用计数各为1（互相引用），无法释放 </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">（无析构输出，内存泄漏）</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>避免循环引用：</strong> 用 <code>weak_ptr</code> 代替 <code>shared_ptr</code> 来打破循环</p>
<p><strong>不要用裸指针初始化多个shared_ptr：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int* p = new int; </span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;int&gt; sp1(p); </span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;int&gt; sp2(p);</span><br><span class="line"></span><br><span class="line">会导致p被释放两次（程序崩溃）</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>优先使用make_shared：</strong> <code>make_shared</code> 比 <code>new</code> 更高效，且避免内存泄漏（例如 <code>new</code> 后构造函数抛出异常， <code>make_shared</code> 会自动回收内存</p>
</blockquote>
<p><strong><code>弱引用的智能指针</code></strong></p>
<blockquote>
<p><strong>弱引用：</strong> 指向 <code>shared_ptr</code> 管理的对象，但不增加引用计数（不影响对象的生命周期）</p>
<p><strong>解决循环引用：</strong> 当两个对象互相引用时，用 <code>weak_ptr</code> 代替其中一个 <code>shared_ptr</code> ，打破循环</p>
<p><strong>需锁定访问：</strong> 不能直接访问对象，必须通过 <code>lock()</code> 方法获取 <code>shared_ptr</code> （若对象已释放， <code>lock() </code>返回 <code>nullptr</code> ）</p>
</blockquote>
<p><code>修改上面的循环引用例子，将j结构体 B 中的 shared_ptr&lt;A&gt; 改为 weak_ptr&lt;A&gt; </code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">struct A &#123; </span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr;</span><br><span class="line">    ~A() &#123; std::cout &lt;&lt; &quot;A destructed.\n&quot;; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">struct B &#123; </span><br><span class="line">    std::weak_ptr&lt;A&gt; a_ptr; // 用weak_ptr代替shared_ptr </span><br><span class="line">    ~B() &#123; std::cout &lt;&lt; &quot;B destructed.\n&quot;; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">int main() &#123; </span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;(); </span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;(); </span><br><span class="line">    a-&gt;b_ptr = b; // A引用B（shared_ptr）</span><br><span class="line">    b-&gt;a_ptr = a; // B引用A（weak_ptr，不增加引用计数）</span><br><span class="line"> </span><br><span class="line">    // a析构时，引用计数变为0（b的a_ptr是weak_ptr，不影响），释放A； </span><br><span class="line">    // A释放后，b的引用计数变为0（a的b_ptr是shared_ptr），释放B。 </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"></span><br><span class="line">A destructed</span><br><span class="line"></span><br><span class="line">B destructed</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>访问 weak_ptr 指向的对象：</strong> 需通过<code>lock()</code>方法获取 <code>shared_ptr</code> ，若对象已释放， <code>lock()</code> 返回 <code>nullptr</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Test&gt; sp = std::make_shared&lt;Test&gt;(1); </span><br><span class="line">std::weak_ptr&lt;Test&gt; wp = sp; // 从shared_ptr构造weak_ptr </span><br><span class="line"> </span><br><span class="line">// 方式1：用lock()获取shared_ptr </span><br><span class="line">if (auto locked_sp = wp.lock())  &#123; </span><br><span class="line">    locked_sp-&gt;show(); // 访问对象 </span><br><span class="line">&#125; else &#123; </span><br><span class="line">    std::cout &lt;&lt; &quot;Object has been destructed.\n&quot;; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">// 方式2：用expired()判断对象是否已释放 </span><br><span class="line">if (!wp.expired())  &#123; </span><br><span class="line">    auto locked_sp = wp.lock();  </span><br><span class="line">    locked_sp-&gt;show(); </span><br><span class="line">&#125; else &#123; </span><br><span class="line">    std::cout &lt;&lt; &quot;Object has been destructed.\n&quot;; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">sp.reset();  // 释放对象 </span><br><span class="line">if (wp.expired())  &#123; </span><br><span class="line">    std::cout &lt;&lt; &quot;Object has been destructed.\n&quot;; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">Test 1 constructed</span><br><span class="line"></span><br><span class="line">Test 1 is alive</span><br><span class="line"></span><br><span class="line">Test 1 is alive</span><br><span class="line"></span><br><span class="line">Test 1 destructed</span><br><span class="line"></span><br><span class="line">Object has been destructed</span><br></pre></td></tr></table></figure>

<p><strong>函数</strong> </p>
<blockquote>
<p>函数包含逻辑代码，可被程序多次调用，一个完整的函数定义主要包括：返回类型、函数名、参数列表和函数体</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(参数列表) &#123;</span><br><span class="line">    // 函数体 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>返回类型：</strong> 指定返回值的数据类型（如 <code>void</code> 表示无返回值）</p>
<p><strong>函数名称：</strong> 这是函数的实际名称。函数名和参数列表一起构成了函数签名（告知编译器）</p>
<p><strong>参数列表：</strong> 参数就像是占位符，可为空或包含多个参数，参数按值传递（拷贝副本）或引用传递（修改原始数据）</p>
<p><strong>函数体：</strong> 函数要执行的语句块，函数的主体</p>
</blockquote>
<p><strong>高级特性</strong></p>
<blockquote>
<p><strong>函数重载：</strong> 是 C++ 中编译时多态的核心机制之一，重载函数的声明和定义与普通函数类似，但需保证参数列表不同，通过不同参数列表实现同名函数，需满足参数类型、个数或顺序差异</p>
</blockquote>
<p><strong><code>1. 参数个数不同</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void fun() </span><br><span class="line">void fun(int a)</span><br></pre></td></tr></table></figure>

<p><strong><code>2. 参数类型不同</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void fun(int a) </span><br><span class="line">void fun(double a)</span><br></pre></td></tr></table></figure>

<p><strong><code>3. 参数顺序不同：</code></strong> 不同顺序中需要有不同的类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void fun(int a, double b) </span><br><span class="line">void fun(double a, int b)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void fun(int a, int b) </span><br><span class="line">void fun(int b int a)</span><br><span class="line"></span><br><span class="line">// 这种是不行的, 形参名的调换不构成重载</span><br></pre></td></tr></table></figure>

<p><code>注意：返回值类型不同不能作为函数重载的依据</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 无法重载，编译器会报错“重定义”</span><br><span class="line"></span><br><span class="line">int fun()</span><br><span class="line">void fun()</span><br></pre></td></tr></table></figure>

<p><strong><code>引用参数的特殊处理</code></strong></p>
<blockquote>
<p>当重载函数包含引用参数（ <code>int&amp;</code> 、<code>const int&amp;</code> 、<code>int&amp;&amp;</code> ）时，编译器会根据实参的左值&#x2F;右值属性匹配</p>
</blockquote>
<p><strong>1. int&amp;：</strong> 匹配可修改的左值（如变量）</p>
<p><strong>2. const int&amp;：</strong> 匹配不可修改的左值（如 <code>const</code> 变量）或右值（如表达式结果）</p>
<p><strong>3. int&amp;&amp;：</strong> 匹配右值（如临时对象、表达式结果）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void fun(int&amp; a) &#123; cout &lt;&lt; &quot;左值引用: &quot; &lt;&lt; a &lt;&lt; endl; &#125; </span><br><span class="line">void fun(const int&amp; a) &#123; cout &lt;&lt; &quot;const左值引用: &quot; &lt;&lt; a &lt;&lt; endl; &#125; </span><br><span class="line">void fun(int&amp;&amp; a) &#123; cout &lt;&lt; &quot;右值引用: &quot; &lt;&lt; a &lt;&lt; endl; &#125; </span><br><span class="line"> </span><br><span class="line">int main() &#123; </span><br><span class="line">    int a = 10;          // 左值</span><br><span class="line">    const int b = 20;    // const左值 </span><br><span class="line">    fun(a);              // 调用 fun(int&amp;) </span><br><span class="line">    fun(b);              // 调用 fun(const int&amp;) </span><br><span class="line">    fun(a + b);          // 调用 fun(int&amp;&amp;)（a+b是右值） </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"></span><br><span class="line">左值引用: 10 </span><br><span class="line"></span><br><span class="line">const左值引用: 20 </span><br><span class="line"></span><br><span class="line">右值引用: 30 </span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>函数重载仅在同一作用域内有效：</strong> </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void fun() &#123; cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; endl; &#125;  // 全局作用域</span><br><span class="line"> </span><br><span class="line">class MyClass &#123; </span><br><span class="line">public:</span><br><span class="line">    void fun() &#123; cout &lt;&lt; &quot;类成员函数&quot; &lt;&lt; endl; &#125;  // 类作用域</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">int main() &#123; </span><br><span class="line">    fun();                // 调用全局函数 </span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.fun();             // 调用类成员函数 </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>上述代码不会报错，因为两个fun函数属于不同作用域</code></p>
<p><strong><code>默认参数</code></strong></p>
<blockquote>
<p>在声明或定义中为参数指定默认值，调用时可省略</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void display(int a = 10, int b = 20) &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">display();</span><br></pre></td></tr></table></figure>

<p><strong><code>内联函数</code></strong></p>
<blockquote>
<p>使用 <code>inline</code> 关键字建议编译器展开函数体，也就是代码直接嵌入调用处，减少调用开销</p>
</blockquote>
<p><strong><code>适用于：</code></strong> （通常 ≤ 10行代码）且频繁调用（如循环内部）、类成员访问器（ <code>getter/setter</code> ）</p>
<p><strong><code>不适用于：</code></strong> 函数体含循环&#x2F;递归、代码较长（导致代码膨胀）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 正确方式：定义时加 inline 关键字（声明中加无效）</span><br><span class="line">inline int add(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 类内定义自动内联（无需显式写 inline）</span><br><span class="line">class Circle &#123;</span><br><span class="line">private:</span><br><span class="line">    double radius;</span><br><span class="line">public:</span><br><span class="line">    double getArea() &#123; // 自动视为内联 </span><br><span class="line">        return 3.14 * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// 类外定义需显式 inline </span><br><span class="line">class Circle &#123;</span><br><span class="line">public:</span><br><span class="line">    double getArea();</span><br><span class="line">&#125;;</span><br><span class="line">inline double Circle::getArea() &#123; </span><br><span class="line">    return 3.14 * radius * radius; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>递归函数</code></strong></p>
<blockquote>
<p>函数直接或间接调用自身，需设置基准条件避免无限递归</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int factorial(int n) &#123; </span><br><span class="line">  return n == 1 ? 1 : n * factorial(n-1); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Lambda 函数与表达式</code></strong></p>
<blockquote>
<p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)，它们通常用于需要一个小型、临时的函数，以便在某个上下文中使用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture_list](parameter_list) mutable -&gt; return_type &#123; function_body; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>捕获列表 (capture_list)：</strong> 指定哪些外部变量可以被 Lambda 函数访问，以及是以值还是引用的方式访问</p>
<blockquote>
<p><strong>mutable：</strong>允许修改值捕获的副本（默认不可修改）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line"></span><br><span class="line">    // 使用 mutable 关键字允许修改按值捕获的变量</span><br><span class="line">    auto lambda = [x]() mutable &#123;</span><br><span class="line">        x += 5;</span><br><span class="line">        std::cout &lt;&lt; &quot;x inside lambda: &quot; &lt;&lt; x &lt;&lt; std::endl; // 输出: x inside lambda: 15</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    lambda();</span><br><span class="line">    std::cout &lt;&lt; &quot;x outside lambda: &quot; &lt;&lt; x &lt;&lt; std::endl; // 输出: x outside lambda: 10</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>常见的捕获方式包括</code></strong></p>
<blockquote>
<p><strong><code>[]</code>：</strong> 不捕获任何变量，使用未定义变量会引发错误</p>
<p><strong><code>[&amp;]</code>：</strong> 捕获所有外部变量的引用，任何被使用到的外部变量都隐式地以引用方式加以引用</p>
<p><strong><code>[=]</code>：</strong> 捕获所有外部变量的值（副本），任何被使用到的外部变量都隐式地以传值方式加以引用</p>
<p><strong><code>[a, &amp;b]</code>：</strong> 变量 a 按值捕获，变量 b 按引用捕获</p>
<p><strong><code>[=, &amp;a, &amp;b]</code>：</strong> 除 a 和 b 按引用捕获外，其他变量按值捕获</p>
<p><strong><code>[&amp;, a, b]</code>：</strong> 除 a 和 b 按值捕获外，其他变量按引用捕获</p>
<p><strong><code>[this]</code>：</strong> 捕获指向当前对象的 this 指针（访问成员变量）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line">    int y = 5;</span><br><span class="line"></span><br><span class="line">    // 按值捕获 x，按引用捕获 y</span><br><span class="line">    auto lambda = [=, &amp;y]() -&gt; int &#123;</span><br><span class="line">        x += 2;</span><br><span class="line">        y += 3;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int result = lambda();</span><br><span class="line">    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; // 输出: Result: 20</span><br><span class="line">    std::cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot;, y: &quot; &lt;&lt; y &lt;&lt; std::endl; // 输出: x: 10, y: 8</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数列表 (parameter_list)：</strong> Lambda 函数的参数列表，类似于普通函数</p>
<p><strong>返回类型 (return_type)：</strong> Lambda 函数的返回类型，可以省略，编译器会自动推断</p>
<p><strong>函数体 (function_body)：</strong> Lambda 函数的具体实现代码</p>
<p><strong><code>虚函数和纯虚函数</code></strong></p>
<blockquote>
<p>虚函数允许子类重写父类的方法。纯虚函数是一种没有实现的方法，要求子类必须实现</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void display() = 0; // 纯虚函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    void display() override &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Derived class&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><code>友元函数</code></strong></p>
<blockquote>
<p>友元函数是一种非成员函数，但可以访问其私有和受保护的成员。友元函数通过在类内部使用 <code>friend</code> 关键字声明，从而获得访问类私有成员的权限。友元函数不是类的成员函数，因此不能使用 <code>this</code> 指针</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">private:</span><br><span class="line">    int width;</span><br><span class="line">public:</span><br><span class="line">    Box(int w) : width(w) &#123;&#125;</span><br><span class="line">    friend int friendGetArea(Box box);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int friendGetArea(Box box) &#123;</span><br><span class="line">    return box.width * box.width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Box box(5);</span><br><span class="line">    std::cout &lt;&lt; friendGetArea(box) &lt;&lt; std::endl; // 输出: Area: 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>构造函数和拷贝构造函数</code></strong></p>
<blockquote>
<p>构造函数在创建对象时自动调用，用于初始化资源和状态。拷贝构造函数用于从现有对象复制数据到新对象</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    A() &#123;&#125; // 构造函数</span><br><span class="line">    A(const A&amp; other) &#123;&#125; // 拷贝构造函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>引用</strong> </p>
<blockquote>
<p>引用是C++中的一种特殊的数据类型描述，用于在程序的不同部分使用两个以上的变量名指向同一块地址，使得对其中任何一个变量的操作实际上都是对同一地址单元进行的操作。引用的声明方式为：类型名称 <code>&amp;</code> 引用名 <code>=</code> 原名</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int&amp; b = a; // b是a的引用 </span><br><span class="line">b = 20;     // 修改b会同步修改a</span><br><span class="line">cout &lt;&lt; a; // 输出20 [3]()</span><br></pre></td></tr></table></figure>

<p><strong><code>引用的核心特点</code></strong></p>
<p><strong>1. 必须初始化：</strong> 声明时必须绑定目标变量，如 <code>int&amp; b = a</code></p>
<p><strong>2. 无独立内存空间：</strong> 引用与目标变量共享内存地址，<code>&amp;b == &amp;a</code></p>
<p><strong>3. 不可重新绑定：</strong> 一旦绑定目标变量，无法再指向其他变量</p>
<p><strong>4. 安全性优势：</strong> 不能为 <code>NULL</code>，避免空指针风险</p>
<p><strong>5. 引用作为函数参数：</strong> 使用引用传递参数能避免数据副本，提高效率，且更清晰</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void exchange(int&amp; x, int&amp; y) &#123;</span><br><span class="line">    int temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    cout &lt;&lt; &quot;请输入两个数字: &quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    exchange(a, b);</span><br><span class="line">    cout &lt;&lt; &quot;交换后: &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常量</strong> </p>
<blockquote>
<p>常量是固定且不可变的值，一旦初始化，其值在程序中不可改变。常量通常使用 <code>const</code> 关键字修饰，常量的作用域与其他变量相同，可以是块作用域、函数作用域、文件作用域或命名空间作用域</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void example() &#123;</span><br><span class="line">    const int BLOCK_CONSTANT = 5; // 块作用域</span><br><span class="line">    // BLOCK_CONSTANT 只能在 example 函数内部使用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const int GLOBAL_CONSTANT = 10; // 文件作用域</span><br><span class="line">// GLOBAL_CONSTANT 可以在整个文件中使用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常量可以是任何基本数据类型或复合数据类型，包括指针（但指针指向的内容可以被修改，除非指针本身也是指向常量的指针）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int* ptr; // 指针指向的值是常量</span><br><span class="line">int* const ptr2; // 指针本身是常量</span><br><span class="line">const int* const ptr3; // 指针本身和指向的值都是常量</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常量引用可以初始化为左值或右值，但初始化为右值时，只能使用 <code>const T&amp;</code> 类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">const int&amp; ref = a; // 正确</span><br><span class="line">const int&amp; ref2 = 20; // 正确</span><br><span class="line">int&amp; ref3 = 30; // 错误</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>常量函数：</strong> 通过在函数名后添加 <code>const</code> 关键字声明为常量函数，这些函数不能改变对象的值，且只能由非常量对象调用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Example &#123;</span><br><span class="line">public:</span><br><span class="line">    int getValue() const &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    int value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>四、 运算符</strong></p>
<blockquote>
<p>包括算术运算符（+, -, *, &#x2F;, %）、关系运算符（&#x3D;&#x3D;, !&#x3D;, &gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;）、逻辑运算符（&amp;&amp;, ||, !）等</p>
</blockquote>
<p><strong><code>算术运算符</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 10, b = 20;</span><br><span class="line">    cout &lt;&lt; &quot;加法: &quot; &lt;&lt; a + b &lt;&lt; endl; // 输出: 30</span><br><span class="line">    cout &lt;&lt; &quot;减法: &quot; &lt;&lt; a - b &lt;&lt; endl; // 输出: -10</span><br><span class="line">    cout &lt;&lt; &quot;乘法: &quot; &lt;&lt; a * b &lt;&lt; endl; // 输出: 200</span><br><span class="line">    cout &lt;&lt; &quot;除法: &quot; &lt;&lt; b / a &lt;&lt; endl; // 输出: 2</span><br><span class="line">    cout &lt;&lt; &quot;取模: &quot; &lt;&lt; b % a &lt;&lt; endl; // 输出: 0</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>关系运算符</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 10, b = 20;</span><br><span class="line">    cout &lt;&lt; &quot;等于: &quot; &lt;&lt; (a == b) &lt;&lt; endl; // 输出: 0 (false)</span><br><span class="line">    cout &lt;&lt; &quot;不等于: &quot; &lt;&lt; (a != b) &lt;&lt; endl; // 输出: 1 (true)</span><br><span class="line">    cout &lt;&lt; &quot;大于: &quot; &lt;&lt; (a &gt; b) &lt;&lt; endl; // 输出: 0 (false)</span><br><span class="line">    cout &lt;&lt; &quot;小于: &quot; &lt;&lt; (a &lt; b) &lt;&lt; endl; // 输出: 1 (true)</span><br><span class="line">    cout &lt;&lt; &quot;大于等于: &quot; &lt;&lt; (a &gt;= b) &lt;&lt; endl; // 输出: 0 (false)</span><br><span class="line">    cout &lt;&lt; &quot;小于等于: &quot; &lt;&lt; (a &lt;= b) &lt;&lt; endl; // 输出: 1 (true)</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>逻辑运算符</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    bool x = true, y = false;</span><br><span class="line">    cout &lt;&lt; &quot;逻辑与: &quot; &lt;&lt; (x &amp;&amp; y) &lt;&lt; endl; // 输出: 0 (false)</span><br><span class="line">    cout &lt;&lt; &quot;逻辑或: &quot; &lt;&lt; (x || y) &lt;&lt; endl; // 输出: 1 (true)</span><br><span class="line">    cout &lt;&lt; &quot;逻辑非: &quot; &lt;&lt; (!x) &lt;&lt; endl; // 输出: 0 (false)</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>赋值运算符</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = a; // 基本赋值</span><br><span class="line">    int c = 20;</span><br><span class="line">    c += a; // 加法赋值，等价于 c = c + a</span><br><span class="line">    c -= a; // 减法赋值，等价于 c = c - a</span><br><span class="line">    c *= a; // 乘法赋值，等价于 c = c * a</span><br><span class="line">    c /= a; // 除法赋值，等价于 c = c / a</span><br><span class="line">    c %= a; // 取模赋值，等价于 c = c % a</span><br><span class="line">    cout &lt;&lt; &quot;基本赋值: &quot; &lt;&lt; b &lt;&lt; endl; // 输出: 10</span><br><span class="line">    cout &lt;&lt; &quot;加法赋值: &quot; &lt;&lt; c &lt;&lt; endl; // 输出: 30</span><br><span class="line">    cout &lt;&lt; &quot;减法赋值: &quot; &lt;&lt; c &lt;&lt; endl; // 输出: 20</span><br><span class="line">    cout &lt;&lt; &quot;乘法赋值: &quot; &lt;&lt; c &lt;&lt; endl; // 输出: 200</span><br><span class="line">    cout &lt;&lt; &quot;除法赋值: &quot; &lt;&lt; c &lt;&lt; endl; // 输出: 20</span><br><span class="line">    cout &lt;&lt; &quot;取模赋值: &quot; &lt;&lt; c &lt;&lt; endl; // 输出: 0</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>指针运算符</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int var = 20;</span><br><span class="line">    int *ptr = &amp;var; // 取地址</span><br><span class="line">    cout &lt;&lt; &quot;变量的地址: &quot; &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;通过指针访问变量的值: &quot; &lt;&lt; *ptr &lt;&lt; endl; // 解引用</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>位运算符</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 60; // 二进制表示为 0011 1100</span><br><span class="line">    int b = 13; // 二进制表示为 0000 1101</span><br><span class="line">    cout &lt;&lt; &quot;按位与: &quot; &lt;&lt; (a &amp; b) &lt;&lt; endl; // 输出: 12 (二进制 0000 1100)</span><br><span class="line">    cout &lt;&lt; &quot;按位或: &quot; &lt;&lt; (a | b) &lt;&lt; endl; // 输出: 61 (二进制 0011 1101)</span><br><span class="line">    cout &lt;&lt; &quot;按位异或: &quot; &lt;&lt; (a ^ b) &lt;&lt; endl; // 输出: 49 (二进制 0011 0001)</span><br><span class="line">    cout &lt;&lt; &quot;左移: &quot; &lt;&lt; (a &lt;&lt; 2) &lt;&lt; endl; // 输出: 240 (二进制 1111 0000)</span><br><span class="line">    cout &lt;&lt; &quot;右移: &quot; &lt;&lt; (a &gt;&gt; 2) &lt;&lt; endl; // 输出: 15 (二进制 0000 1111)</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>五、控制结构</strong></p>
<blockquote>
<p>包括 <code>if-else</code> 、<code>switch</code> 、<code>for</code> 、<code>while</code> 等循环和条件语句</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (x &gt; 0) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Positive number&quot;;</span><br><span class="line">&#125; else if (x == 0) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Zero&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Negative number&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char op;</span><br><span class="line">    float num1, num2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Enter operator either + or - or * or /: &quot;;</span><br><span class="line">    cin &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Enter two operands: &quot;;</span><br><span class="line">    cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line"></span><br><span class="line">    switch(op) &#123;</span><br><span class="line">        case &#x27;+&#x27;:</span><br><span class="line">            cout &lt;&lt; num1 + num2;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case &#x27;-&#x27;:</span><br><span class="line">            cout &lt;&lt; num1 - num2;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case &#x27;*&#x27;:</span><br><span class="line">            cout &lt;&lt; num1 * num2;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case &#x27;/&#x27;:</span><br><span class="line">            if(num2 != 0.0)</span><br><span class="line">                cout &lt;&lt; num1 / num2;</span><br><span class="line">            else</span><br><span class="line">                cout &lt;&lt; &quot;Divide by zero situation&quot;;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            cout &lt;&lt; &quot;Error! operator is not correct&quot;;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    if (i == 5) break;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int i = 0;</span><br><span class="line">while (i &lt; 10) &#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int i = 0;</span><br><span class="line">do &#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">    i++;</span><br><span class="line">&#125; while (i &lt; 10);</span><br></pre></td></tr></table></figure>

<h1 id="4-面向对象编程（OOP）"><a href="#4-面向对象编程（OOP）" class="headerlink" title="4. 面向对象编程（OOP）"></a>4. 面向对象编程（OOP）</h1><blockquote>
<p>C++ 是一种面向对象的编程语言，支持 <code>OOP</code> 的核心概念</p>
</blockquote>
<h3 id="1-类（Class）"><a href="#1-类（Class）" class="headerlink" title="1. 类（Class）"></a>1. 类（Class）</h3><blockquote>
<p>定义对象的蓝图，包含数据成员和成员函数</p>
</blockquote>
<h3 id="2-对象（Object）"><a href="#2-对象（Object）" class="headerlink" title="2. 对象（Object）"></a>2. 对象（Object）</h3><blockquote>
<p> 类的实例，具有类定义的属性和行为</p>
</blockquote>
<h3 id="3-封装（Encapsulation）"><a href="#3-封装（Encapsulation）" class="headerlink" title="3. 封装（Encapsulation）"></a>3. 封装（Encapsulation）</h3><blockquote>
<p> 通过访问修饰符（ <code>public</code> ,  <code>private</code> ,  <code>protected</code> ）控制类的内部成员的访问</p>
</blockquote>
<h3 id="4-继承（Inheritance）"><a href="#4-继承（Inheritance）" class="headerlink" title="4. 继承（Inheritance）"></a>4. 继承（Inheritance）</h3><blockquote>
<p> 子类可以继承父类的属性和方法，实现代码复用 </p>
</blockquote>
<h3 id="5-多态（Polymorphism）"><a href="#5-多态（Polymorphism）" class="headerlink" title="5. 多态（Polymorphism）"></a>5. 多态（Polymorphism）</h3><blockquote>
<p> 通过虚函数实现不同类对象的统一接口，提高代码的灵活性 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Rectangle &#123;</span><br><span class="line">public:</span><br><span class="line">    int width, height;</span><br><span class="line">    Rectangle(int w, int h) : width(w), height(h) &#123;&#125;</span><br><span class="line">    int area() const &#123;</span><br><span class="line">        return width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Rectangle rect(5, 10);</span><br><span class="line">    std::cout &lt;&lt; &quot;Area: &quot; &lt;&lt; rect.area() &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>输出：Area: 50</code></p>
<h1 id="5-标准模板库（STL）"><a href="#5-标准模板库（STL）" class="headerlink" title="5. 标准模板库（STL）"></a>5. 标准模板库（STL）</h1><blockquote>
<p>C++ 的 <code>STL</code> 提供了丰富的容器、算法和迭代器，简化了开发过程 </p>
</blockquote>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><blockquote>
<p>管理数据的集合，封装存储结构</p>
</blockquote>
<h3 id="常用的容器包括"><a href="#常用的容器包括" class="headerlink" title="常用的容器包括"></a>常用的容器包括</h3><blockquote>
<p><strong>向量（vector）：</strong> 动态数组，支持随机访问</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">push_back(value)：在向量末尾添加一个元素</span><br><span class="line"></span><br><span class="line">pop_back()：移除向量的最后一个元素</span><br><span class="line"></span><br><span class="line">at(index)：返回指定索引位置的元素，如果索引越界会抛出异常</span><br><span class="line"></span><br><span class="line">operator[]：返回指定索引位置的元素，不进行越界检查</span><br><span class="line"></span><br><span class="line">front()：返回向量的第一个元素</span><br><span class="line"></span><br><span class="line">back()：返回向量的最后一个元素</span><br><span class="line"></span><br><span class="line">begin()：返回指向向量第一个元素的迭代器</span><br><span class="line"></span><br><span class="line">end()：返回指向向量末尾元素后一个位置的迭代器</span><br><span class="line"></span><br><span class="line">size()：返回向量中元素的数量</span><br><span class="line"></span><br><span class="line">capacity()：返回当前向量分配的内存大小</span><br><span class="line"></span><br><span class="line">resize(new_size, value)：调整向量大小，如果新大小大于当前大小，则用指定值填充新元素；如果新大小小于当前大小，则删除多余元素</span><br><span class="line"></span><br><span class="line">reserve(new_capacity)：预先分配足够的内存空间，避免频繁的内存重新分配</span><br><span class="line"></span><br><span class="line">clear()：清空向量中的所有元素</span><br><span class="line"></span><br><span class="line">empty()：判断向量是否为空</span><br><span class="line"></span><br><span class="line">swap(other_vector)：交换两个向量的内容</span><br><span class="line"></span><br><span class="line">insert(position, value)：在指定位置插入一个元素</span><br><span class="line"></span><br><span class="line">erase(position)：删除指定位置的元素</span><br><span class="line"></span><br><span class="line">sort()：对向量中的元素进行排序</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt; // for sort function</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 声明一个整数向量</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line"></span><br><span class="line">    // 使用 push_back 添加元素</span><br><span class="line">    vec.push_back(10);</span><br><span class="line">    vec.push_back(20);</span><br><span class="line">    vec.push_back(30);</span><br><span class="line"></span><br><span class="line">    // 使用 at 访问元素</span><br><span class="line">    cout &lt;&lt; &quot;Element at index 1: &quot; &lt;&lt; vec.at(1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 使用 operator[] 访问元素</span><br><span class="line">    cout &lt;&lt; &quot;Element at index 2: &quot; &lt;&lt; vec[2] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 使用 front 和 back 访问首尾元素</span><br><span class="line">    cout &lt;&lt; &quot;First element: &quot; &lt;&lt; vec.front() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;Last element: &quot; &lt;&lt; vec.back() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 使用 begin 和 end 遍历向量</span><br><span class="line">    cout &lt;&lt; &quot;Vector elements: &quot;;</span><br><span class="line">    for (auto it = vec.begin(); it != vec.end(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 使用 size 获取向量大小</span><br><span class="line">    cout &lt;&lt; &quot;Size of vector: &quot; &lt;&lt; vec.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 使用 capacity 获取向量容量</span><br><span class="line">    cout &lt;&lt; &quot;Capacity of vector: &quot; &lt;&lt; vec.capacity() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 使用 resize 调整向量大小</span><br><span class="line">    vec.resize(5, 0); // 调整为5个元素，新元素初始化为0</span><br><span class="line">    cout &lt;&lt; &quot;After resizing, size: &quot; &lt;&lt; vec.size() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;After resizing, elements: &quot;;</span><br><span class="line">    for (int num : vec) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 使用 reserve 预先分配内存</span><br><span class="line">    vec.reserve(10);</span><br><span class="line">    cout &lt;&lt; &quot;After reserving, capacity: &quot; &lt;&lt; vec.capacity() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 使用 clear 清空向量</span><br><span class="line">    vec.clear();</span><br><span class="line">    cout &lt;&lt; &quot;After clearing, size: &quot; &lt;&lt; vec.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 使用 empty 判断向量是否为空</span><br><span class="line">    if (vec.empty()) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Vector is empty.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用 insert 插入元素</span><br><span class="line">    vec.insert(vec.begin(), 5);</span><br><span class="line">    vec.insert(vec.begin() + 1, 15);</span><br><span class="line">    cout &lt;&lt; &quot;After inserting elements, vector: &quot;;</span><br><span class="line">    for (int num : vec) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 使用 erase 删除元素</span><br><span class="line">    vec.erase(vec.begin() + 1);</span><br><span class="line">    cout &lt;&lt; &quot;After erasing element at index 1, vector: &quot;;</span><br><span class="line">    for (int num : vec) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 使用 sort 对向量进行排序</span><br><span class="line">    vector&lt;int&gt; numbers = &#123;3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5&#125;;</span><br><span class="line">    sort(numbers.begin(), numbers.end());</span><br><span class="line">    cout &lt;&lt; &quot;Sorted vector: &quot;;</span><br><span class="line">    for (int num : numbers) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>列表（list）：</strong> 双向链表，支持插入和删除操作</p>
</blockquote>
<p><strong><code>构造函数</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; a&#123;1, 2, 3&#125;;：初始化一个包含元素1, 2, 3的列表</span><br><span class="line">list&lt;int&gt; a(n);：声明一个包含n个元素的列表，每个元素都是0</span><br><span class="line">list&lt;int&gt; a(n, m);：声明一个包含n个元素的列表，每个元素都是m</span><br><span class="line">list&lt;int&gt; a(first, last);：声明一个列表，其元素的初始值来源于由区间所指定的序列中的元素，first和last是迭代器</span><br></pre></td></tr></table></figure>

<p><strong><code>插入元素</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push_front(value)：将元素从前面推入列表</span><br><span class="line">push_back(value)：在列表末尾插入一个新元素</span><br><span class="line">insert(pos_iter, ele_num, ele)：在指定位置插入指定数量的元素</span><br><span class="line">emplace_front(args...)：在列表开头构造元素</span><br><span class="line">emplace_back(args...)：在列表末尾构造元素</span><br></pre></td></tr></table></figure>

<p><strong><code>删除元素</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop_front()：从正面弹出或删除列表中的元素</span><br><span class="line">pop_back()：从末尾弹出或删除列表中的元素</span><br><span class="line">remove(value)：删除所有与给定值相等的元素</span><br><span class="line">remove_if(predicate)：删除所有对谓词返回true的元素</span><br><span class="line">clear()：删除列表容器的所有元素，使其大小为0</span><br></pre></td></tr></table></figure>

<p><strong><code>检查状态</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">empty()：检查列表容器是否为空。</span><br><span class="line">size()：返回列表中元素的数量。</span><br></pre></td></tr></table></figure>

<p><strong><code>其他操作</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assign(first, last)：将新内容分配给列表容器，并用新内容替换旧内容</span><br><span class="line">sort()：对列表进行排序</span><br><span class="line">reverse()：反转列表中元素的顺序</span><br><span class="line">merge(other_list)：合并两个已排序的列表</span><br><span class="line">unique()：删除连续重复的元素</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    list&lt;int&gt; mylist&#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    mylist.push_front(6); // 在前面插入6</span><br><span class="line">    mylist.push_back(7);  // 在末尾插入7</span><br><span class="line"></span><br><span class="line">    for (auto it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">        cout &lt;&lt; &#x27; &#x27; &lt;&lt; *it;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>映射（map）：</strong> 键值对集合，支持快速查找，<code>map</code> 中的键必须是唯一的。如果插入一个已经存在的键，新的值不会替换原有值，而是忽略插入操作，<code>map</code> 内部会自动根据键的大小进行排序，因此遍历时元素是按顺序排列的，由于 <code>map</code> 基于红黑树实现，查找、插入和删除操作的时间复杂度为 <code>O(log n)</code>，适合需要频繁查找和修改的场景</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">插入元素：</span><br><span class="line">insert(pair&lt;const Key, T&gt; val)：插入一个键值对</span><br><span class="line">operator[]：通过键访问或插入值。如果键不存在，则插入默认值</span><br><span class="line"></span><br><span class="line">访问元素：</span><br><span class="line">operator[]：通过键访问值</span><br><span class="line">at(const Key&amp; key)：通过键访问值，如果键不存在则抛出异常</span><br><span class="line"></span><br><span class="line">查找元素：</span><br><span class="line">find(const Key&amp; key)：返回指向键为 key 的元素的迭代器，如果不存在则返回 end()</span><br><span class="line">count(const Key&amp; key)：返回键为 key 的元素数量（对于 map，返回 0 或 1）</span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">erase(iterator position)：删除指定位置的元素</span><br><span class="line">erase(const Key&amp; key)：删除键为 key 的元素</span><br><span class="line">clear()：清空所有元素</span><br><span class="line"></span><br><span class="line">遍历元素：</span><br><span class="line">使用迭代器遍历，例如 for (auto it = m.begin(); it != m.end(); ++it)。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个 map 容器</span><br><span class="line">    map&lt;string, int&gt; ageMap;</span><br><span class="line"></span><br><span class="line">    // 添加元素</span><br><span class="line">    ageMap[&quot;Alice&quot;] = 30;</span><br><span class="line">    ageMap[&quot;Bob&quot;] = 25;</span><br><span class="line"></span><br><span class="line">    // 访问元素</span><br><span class="line">    cout &lt;&lt; &quot;Alice&#x27;s age: &quot; &lt;&lt; ageMap[&quot;Alice&quot;] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 遍历 map</span><br><span class="line">    for (const auto&amp; pair : ageMap) &#123;</span><br><span class="line">        cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查找元素</span><br><span class="line">    if (ageMap.count(&quot;Bob&quot;)) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Bob is in the map.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除元素</span><br><span class="line">    ageMap.erase(&quot;Alice&quot;);</span><br><span class="line"></span><br><span class="line">    // 清空 map</span><br><span class="line">    ageMap.clear();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>集合（set ）：</strong> 有序集合，支持唯一元素，集合中的元素不能重复，可以添加或删除元素，但不能修改现有元素的值，插入元素时自动排序，元素通过键引用，而非容器中的位置</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">insert()：用于向set中插入元素</span><br><span class="line"></span><br><span class="line">erase()：用于从set中删除元素</span><br><span class="line"></span><br><span class="line">clear()：用于清除set中的所有元素</span><br><span class="line"></span><br><span class="line">empty()：用于检查set是否为空</span><br><span class="line"></span><br><span class="line">size()：用于返回set的大小</span><br><span class="line"></span><br><span class="line">begin()：返回指向第一个元素的迭代器</span><br><span class="line"></span><br><span class="line">end()：返回指向最后一位元素的下一位的迭代器</span><br><span class="line"></span><br><span class="line">find()：查找指定元素，返回其迭代器或结束迭代器</span><br><span class="line"></span><br><span class="line">count()：统计集合中特定元素的数量</span><br><span class="line"></span><br><span class="line">lower_bound()：返回第一个大于等于给定值的值的地址</span><br><span class="line"></span><br><span class="line">upper_bound()：返回第一个大于给定值的值的地址</span><br><span class="line"></span><br><span class="line">equal_range()：返回一个pair，first为第一个大于等于目标的迭代器，second为第一个大于目标的迭代器</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    set&lt;int&gt; s;</span><br><span class="line">    s.insert(10);</span><br><span class="line">    s.insert(20);</span><br><span class="line">    s.insert(30);</span><br><span class="line"></span><br><span class="line">    // 遍历set</span><br><span class="line">    for (int a : s) &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 检查元素是否存在</span><br><span class="line">    if (s.find(20) != s.end()) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;20 exists in set&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除元素</span><br><span class="line">    s.erase(20);</span><br><span class="line"></span><br><span class="line">    // 检查set是否为空</span><br><span class="line">    if (!s.empty()) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Set is not empty&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取set的大小</span><br><span class="line">    cout &lt;&lt; &quot;Size of set: &quot; &lt;&lt; s.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><blockquote>
<p>提供遍历容器的统一接口，连接容器与算法，<code>begin() </code>,  <code>end() </code>, 迭代器是STL中泛化的指针，提供统一接口遍历不同容器（如 <code>vector</code>、<code>list</code> 、<code>map</code> ）的元素</p>
</blockquote>
<p><strong><code>1. 基础遍历（所有容器通用）</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; vec = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">    // 正向遍历 </span><br><span class="line">    for (auto it = vec.begin();  it != vec.end();  ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;  // 输出：1 2 3 4</span><br><span class="line">    &#125;</span><br><span class="line">    // C++11范围for循环（底层基于迭代器）</span><br><span class="line">    for (int val : vec) &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; &quot; &quot;;  // 同上 </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 范围 for 循环内部实现基于迭代器，因此在循环中不能随意增加或删除元素，否则会导致未定义行为</span><br></pre></td></tr></table></figure>

<p><strong><code>2. 反向遍历（双向/随机访问迭代器支持）</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;world&quot;&#125;;</span><br><span class="line">for (auto rit = words.rbegin();  rit != words.rend();  ++rit) &#123;</span><br><span class="line">    cout &lt;&lt; *rit &lt;&lt; &quot; &quot;;  // 输出：world hello </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>3. 插入与删除操作</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v = &#123;10, 20, 30&#125;;</span><br><span class="line">auto it = v.begin()  + 1;</span><br><span class="line">it = v.insert(it,  15);  // 插入后v=&#123;10,15,20,30&#125;，it指向15 </span><br><span class="line">it = v.erase(it);        // 删除15，it指向20（需更新迭代器！）</span><br></pre></td></tr></table></figure>

<p><strong><code>4. 关联容器特例（set/map）</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; s = &#123;5, 2, 8, 1&#125;;</span><br><span class="line">// 遍历自动排序结果：1 2 5 8</span><br><span class="line">for (auto it = s.begin();  it != s.end();  ++it) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">// 查找操作（返回迭代器）</span><br><span class="line">auto pos = s.find(5); </span><br><span class="line">if (pos != s.end())  &#123;</span><br><span class="line">    s.erase(pos);   // 安全删除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>vector的push_back()可能引发扩容，导致所有迭代器失效；erase()使被删元素及之后的迭代器失效</code></p>
<p><code>对vector/deque插入/删除元素后，必须重新获取迭代器。关联容器（如set）删除元素时，优先使用it = container.erase(it) 语法</code></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote>
<p>独立于容器的通用操作（排序、查找等），<code>sort()</code> ,  <code>find() </code>,  <code>copy()</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// sort(): 对容器进行排序</span><br><span class="line">sort(a.begin(), a.end()); // 默认升序排序</span><br><span class="line">sort(a.begin(), a.end(), greater&lt;&gt;()); // 使用greater对象进行降序排序</span><br><span class="line"></span><br><span class="line">// distance(): 计算两个迭代器之间的距离</span><br><span class="line">int dist = distance(a.begin(), a.end()); // 计算a的大小</span><br><span class="line"></span><br><span class="line">// copy(): 将一个范围内的元素复制到另一个范围</span><br><span class="line">vector&lt;int&gt; b(a.size());</span><br><span class="line">copy(a.begin(), a.end(), b.begin()); // 将a的内容复制到b</span><br><span class="line"></span><br><span class="line">// next_permutation(): 生成下一个排列</span><br><span class="line">sort(a.begin(), a.end()); // 先排序</span><br><span class="line">do &#123;</span><br><span class="line">    // 处理当前排列</span><br><span class="line">&#125; while (next_permutation(a.begin(), a.end())); // 生成所有排列</span><br><span class="line"></span><br><span class="line">// set_intersection(): 计算两个集合的交集</span><br><span class="line">vector&lt;int&gt; a&#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">vector&lt;int&gt; b&#123;3, 4, 5, 6, 7&#125;;</span><br><span class="line">vector&lt;int&gt; result;</span><br><span class="line">set_intersection(a.begin(), a.end(), b.begin(), b.end(), back_inserter(result)); // 计算交集</span><br></pre></td></tr></table></figure>

<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><blockquote>
<p>函数对象是重载了 <code>operator()</code> 的类对象，可像函数一样被调用。本质是类实例，而非函数指针，实现定制化操作，谓词（如 <code>greater&lt;int&gt;</code> ），函数对象可包含成员变量，记录调用间的状态（普通函数无法做到）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">struct GreaterThan &#123;</span><br><span class="line">    bool operator()(int a, int b) const &#123;</span><br><span class="line">        return a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;int&gt; vec = &#123;5, 3, 8, 1, 2&#125;;</span><br><span class="line">    std::sort(vec.begin(), vec.end(), GreaterThan());</span><br><span class="line">    for (int num : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><blockquote>
<p>修改组件接口（如容器→栈&#x2F;队列），栈 <code>stack</code> ， 队列 <code>queue</code>， 优先队列 <code>priority_queue</code></p>
</blockquote>
<p><strong><code>栈（stack）</code></strong></p>
<blockquote>
<p>栈是一种后进先出（LIFO）的数据结构。栈适配器可以基于 deque、vector 或 list。默认情况下，栈适配器使用 deque 作为底层容器，只能从栈顶进行插入和删除操作，提供 push()、pop()、top()、empty() 和 size() 等操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个使用 list 作为基础容器的 stack 适配器</span><br><span class="line">    std::list&lt;int&gt; values&#123;1, 2, 3&#125;;</span><br><span class="line">    std::stack&lt;int, std::list&lt;int&gt;&gt; my_stack(values);</span><br><span class="line"></span><br><span class="line">    // 查看 my_stack 存储元素的个数</span><br><span class="line">    std::cout &lt;&lt; &quot;size of my_stack: &quot; &lt;&lt; my_stack.size() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    // 将 my_stack 中存储的元素依次弹栈，直到其为空</span><br><span class="line">    while (!my_stack.empty()) &#123;</span><br><span class="line">        std::cout &lt;&lt; my_stack.top() &lt;&lt; std::endl; // 输出栈顶元素</span><br><span class="line">        my_stack.pop(); // 弹出栈顶元素</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>队列（queue）</code></strong></p>
<blockquote>
<p>队列是一种先进先出（FIFO）的数据结构。队列适配器默认使用 deque 作为底层容器，也可以使用 list，元素在队尾插入并在前端删除，提供 push()、pop()、front()、back()、empty() 和 size() 等操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::queue&lt;int&gt; q;</span><br><span class="line"></span><br><span class="line">    // 在队尾压入新元素</span><br><span class="line">    q.push(1);</span><br><span class="line">    q.push(2);</span><br><span class="line">    q.push(3);</span><br><span class="line"></span><br><span class="line">    // 查看队列长度</span><br><span class="line">    std::cout &lt;&lt; &quot;size of queue: &quot; &lt;&lt; q.size() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    // 将队列中的元素依次弹出，直到其为空</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        std::cout &lt;&lt; q.front() &lt;&lt; std::endl; // 输出队首元素</span><br><span class="line">        q.pop(); // 弹出队首元素</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>优先队列（priority_queue）</code></strong></p>
<blockquote>
<p>优先队列是一种不遵循 FIFO 或 LIFO 原则的数据结构，元素的排序基于优先级（使用最大堆），因此具有最高优先级的元素始终位于前端。优先队列适配器默认使用 vector 作为底层容器，也可以使用 deque，元素的排序基于优先级，提供 push()、pop()、top()、empty() 和 size() 等操作，优先队列适配器不能基于 list，因为 list 不支持随机访问操作，可以自定义比较函数来实现不同的优先级规则</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">    int x, y;</span><br><span class="line">    Node(int a = 0, int b = 0) : x(a), y(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cmp &#123;</span><br><span class="line">    bool operator()(Node a, Node b) &#123;</span><br><span class="line">        if (a.x == b.x) return a.y &gt; b.y;</span><br><span class="line">        return a.x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::priority_queue&lt;Node, std::vector&lt;Node&gt;, cmp&gt; q;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">        q.push(Node(rand(), rand()));</span><br><span class="line"></span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        std::cout &lt;&lt; q.top().x &lt;&lt; &#x27; &#x27; &lt;&lt; q.top().y &lt;&lt; std::endl;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h2><blockquote>
<p>管理堆内存的对象，管理内存分配策略（默认基于 <code>new/delete</code>），<code>allocator&lt;T&gt;</code></p>
</blockquote>
<p><code>分配器提供了多种成员函数</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allocate(size_t n)：分配n个对象所需的内存</span><br><span class="line"></span><br><span class="line">deallocate(T* p, size_t n)：释放由allocate分配的内存</span><br><span class="line"></span><br><span class="line">construct(T* p, const T&amp; val)：在已分配的内存上构造对象</span><br><span class="line"></span><br><span class="line">destroy(T* p)：销毁对象但不解分配内存</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::allocator&lt;int&gt; alloc;</span><br><span class="line">    int* p = alloc.allocate(5); // 分配5个int的内存</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">        alloc.construct(p + i, i * 10); // 构造对象</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; p[i] &lt;&lt; &quot; &quot;; // 输出: 0 10 20 30 40</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">        alloc.destroy(p + i); // 销毁对象</span><br><span class="line">    &#125;</span><br><span class="line">    alloc.deallocate(p, 5); // 释放内存</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-文件操作"><a href="#6-文件操作" class="headerlink" title="6. 文件操作"></a>6. 文件操作</h1><blockquote>
<p>在C++中，文件 <code>I/O</code>（输入&#x2F;输出）是程序与外部世界交换信息的重要手段。它允许程序从文件中读取数据或将数据写入文件。C++标准库提供了多种文件流类来处理文件操作，文件 I&#x2F;O 操作主要通过 <code>&lt;fstream&gt; </code> 库实现</p>
</blockquote>
<h3 id="常用的文件操作包括"><a href="#常用的文件操作包括" class="headerlink" title="常用的文件操作包括"></a>常用的文件操作包括</h3><blockquote>
<p><strong>ifstream：</strong> 用于从文件读取数据，输入文件流（读操作），继承自 <code>istream</code></p>
<p><strong>ofstream：</strong> 用于将数据写入文件，输出文件流（写操作），继承自 <code>ostream</code></p>
<p><strong>fstream：</strong> 用于文件的输入输出，兼具读写功能</p>
<p><strong>打开文件：</strong> 通过构造函数或 <code>open()</code> 成员函数打开文件，并指定文件名和打开模式</p>
<p><strong>读写操作：</strong> 使用插入（&lt;&lt;）或提取（&gt;&gt;）操作符读取或写入文件中的数据</p>
<p><strong>关闭文件：</strong> 使用 <code>close()</code> 函数显式关闭文件，或者让文件 <code>I/O</code> 变量超出作用域（文件I&#x2F;O类的析构函数会自动关闭文件</p>
</blockquote>
<p><code>要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 &lt;iostream&gt; 和 &lt;fstream&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::ifstream src(&quot;source.png&quot;,  std::ios::binary); // 二进制读</span><br><span class="line">    std::ofstream dest(&quot;copy.png&quot;,  std::ios::binary);  // 二进制写</span><br><span class="line"> </span><br><span class="line">    if (!src || !dest) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;文件打开失败！&quot; &lt;&lt; std::endl;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 高效逐块复制 </span><br><span class="line">    const int BUFFER_SIZE = 4096;</span><br><span class="line">    char buffer[BUFFER_SIZE];</span><br><span class="line">    while (src.read(buffer,  BUFFER_SIZE)) &#123;</span><br><span class="line">        dest.write(buffer,  src.gcount());  // 写入实际读取的字节 </span><br><span class="line">    &#125;</span><br><span class="line">    dest.write(buffer,  src.gcount());      // 写入剩余字节 </span><br><span class="line"> </span><br><span class="line">    src.close(); </span><br><span class="line">    dest.close(); </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>结果：copy.png和 source.png一样了</code></p>
<h3 id="文件打开模式"><a href="#文件打开模式" class="headerlink" title="文件打开模式"></a>文件打开模式</h3><blockquote>
<p>要从文件读取信息或者向文件写入信息之前，首先要打开文件，在C++中，文件打开模式可以通过 <code>std::ios_base</code> 类中的标志来指定</p>
</blockquote>
<blockquote>
<p><strong>ios::in：</strong> 以读取模式打开文件</p>
<p><strong>ios::out：</strong> 以写入模式打开文件</p>
<p><strong>ios::app：</strong> 以追加模式打开文件，所有新数据写入到文件的末尾</p>
<p><strong>ios::ate：</strong> 将文件指针定位到文件的末尾</p>
<p><strong>ios::binary：</strong> 以二进制模式打开文件，而不是文本模式</p>
<p><strong>ios::trunc：</strong> 如果文件已存在，则删除文件内容</p>
<p><strong>ios::nocreate：</strong> 如果文件不存在，则打开失败</p>
<p><strong>ios::noreplace：</strong> 如果文件已存在，则打开失败</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    ofstream outFile;</span><br><span class="line">    outFile.open(&quot;number.txt&quot;, ios::app);</span><br><span class="line">    if (!outFile.is_open())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot; problem with opening the file &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        outFile &lt;&lt; 200 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;done writing&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    outFile.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>输出：done writing</code></p>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><blockquote>
<p>读取文件时，可以使用 <code>std::ifstream</code> 类，使用 &gt;&gt; 或 <code>getline</code> 读取文件内容</p>
<p><strong>1. 包含头文件：</strong></p>
<p><code>#include &lt;fstream&gt; </code> &#x2F;&#x2F; 核心文件流库 </p>
<p><code>#include &lt;string&gt;</code>   &#x2F;&#x2F; 用于getline等操作</p>
<p><strong>2. 创建流对象：</strong> <code>std::ifstream fin; </code> &#x2F;&#x2F; <code>ifstream</code> 专用于输入（读取）</p>
<p><strong>3. 打开文件并校验：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fin.open(&quot;data.txt&quot;,  std::ios::in);  // 文本模式打开 </span><br><span class="line">if (!fin.is_open())  &#123;  // 必须检查是否成功打开 </span><br><span class="line">    std::cerr &lt;&lt; &quot;文件打开失败！&quot;;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>模式选项（可组合使用）：</strong> <code>std::ios::in</code>（读）、<code>std::ios::binary</code>（二进制）、<code>std::ios::ate</code>（初始定位到文件末尾）</p>
<p><strong>4. 读取数据：</strong> 四种核心读取方法</p>
<p><strong>方法 1：</strong> 运算符 &gt;&gt;（简单但有限制），<strong>适用场景：</strong> 读取无空格的数据（如数字、单词），<strong>缺陷：</strong> 忽略空格和换行，不保留原始格式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char buffer[100];</span><br><span class="line">while (fin &gt;&gt; buffer) &#123;  // 遇空格/换行终止 </span><br><span class="line">    std::cout &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>方法 2：</strong> <code>std::getline</code>（推荐按行处理），<strong>优势：</strong> 保留行内空格，内存安全（自动处理字符串内存）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string line;</span><br><span class="line">while (std::getline(fin, line)) &#123;  // 读取整行（含空格）</span><br><span class="line">    std::cout &lt;&lt; line &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>方法 3：</strong> 流对象的 <code>getline</code> 方法，<strong>注意：</strong> 需预设缓冲区大小，避免溢出</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char buffer[100];</span><br><span class="line">while (fin.getline(buffer,  100)) &#123;  // 读取到字符数组</span><br><span class="line">    std::cout &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>方法 4：</strong> 逐字符读取（ <code>get()</code> ），<strong>用途：</strong> 需精细控制字符时（如解析特殊结构）<strong>缺点：</strong> 效率低，大文件不推荐</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char ch;</span><br><span class="line">while (fin.get(ch))  &#123;  // 逐个字符读取</span><br><span class="line">    std::cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>特殊场景处理：二进制文件读取</strong> 必须指定 <code>std::ios::binary</code> 模式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::ifstream binFile(&quot;data.bin&quot;,  std::ios::binary);</span><br><span class="line">char* data = new char[1024];</span><br><span class="line">binFile.read(data,  1024);  // 直接读取字节块</span><br><span class="line">binFile.close(); </span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>5. 关闭文件：</strong> <code>fin.close(); </code>  &#x2F;&#x2F; 显式关闭释放资源</p>
</blockquote>
<p><code>二进制模式比文本模式更快（无换行符转换）</code></p>
<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><blockquote>
<p><strong>std::ofstream（输出文件流）：</strong> 专用于写入文件，需包含头文件 <code>&lt;fstream&gt;</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::ofstream fout(&quot;data.txt&quot;);  // 创建或覆盖文件</span><br><span class="line">    if (fout.is_open())  &#123;</span><br><span class="line">        fout &lt;&lt; &quot;Hello, World!\n&quot;; // 写入文本 </span><br><span class="line">        fout.close();  // 必须关闭 </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>std::fstream（多功能文件流）：</strong> 支持读写操作，通过模式参数控制</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::fstream file(&quot;data.txt&quot;,  std::ios::out | std::ios::app); // 追加模式 </span><br><span class="line">file &lt;&lt; &quot;New line\n&quot;;</span><br><span class="line">file.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>写入数据方法</strong></p>
</blockquote>
<blockquote>
<p><strong>1. 文本写入：</strong> 使用 &lt;&lt; 操作符（类似 <code>cout</code> ）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fout &lt;&lt; &quot;Integer: &quot; &lt;&lt; 42 &lt;&lt; &quot;\nFloat: &quot; &lt;&lt; 3.14;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>2. 二进制写入：</strong> 用 write() 直接写入内存数据</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int data = 100;</span><br><span class="line">fout.write(reinterpret_cast&lt;char*&gt;(&amp;data),  sizeof(data)); // 二进制写入</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>3. 格式化控制：</strong> 设置精度与宽度</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fout.precision(2);     // 保留2位小数 </span><br><span class="line">fout.width(10);        // 输出宽度10字符</span><br><span class="line">fout &lt;&lt; 3.14159;      // 输出 &quot;      3.14&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>性能优化与安全</strong></p>
</blockquote>
<blockquote>
<p><strong>1. 缓冲区管理：</strong> 默认有缓冲区，手动刷新可避免数据丢失</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fout &lt;&lt; &quot;Important data&quot;;</span><br><span class="line">fout.flush();  // 立即写入磁盘</span><br><span class="line">调整缓冲区大小（减少I/O次数）：</span><br><span class="line">char buffer[8192]; // 8KB缓冲区 </span><br><span class="line">fout.rdbuf()-&gt;pubsetbuf(buffer,  sizeof(buffer));</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>2. 错误处理：</strong> 检查文件是否成功打开</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!fout) &#123;</span><br><span class="line">    std::cerr &lt;&lt; &quot;File open failed!&quot;;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>3. 线程安全：</strong> 多线程写入时需加锁（如 <code>std::mutex</code> ）</p>
</blockquote>
<p><strong>高级场景</strong></p>
<blockquote>
<p><strong>1. 追加数据</strong> </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::ofstream log(&quot;log.txt&quot;,  std::ios::app);</span><br><span class="line">log &lt;&lt; &quot;Event: User login\n&quot;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>2. 大文件处理：</strong> 分块写入避免内存溢出</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;char&gt; largeData(1000000, &#x27;A&#x27;); // 1MB数据 </span><br><span class="line">fout.write(largeData.data(),  largeData.size()); </span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>3. 跨平台路径处理：</strong> 使用 <code>std::filesystem</code>（C++17起）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;filesystem&gt;</span><br><span class="line">std::ofstream fout(std::filesystem::path(&quot;data/demo.txt&quot;)); </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    // 1. 打开文件（追加模式）</span><br><span class="line">    std::ofstream fout(&quot;output.txt&quot;,  std::ios::app);</span><br><span class="line">    if (!fout) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;Error opening file!&quot;;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 2. 写入数据 </span><br><span class="line">    fout &lt;&lt; &quot;---- New Entry ----\n&quot;;</span><br><span class="line">    fout &lt;&lt; &quot;Timestamp: &quot; &lt;&lt; time(nullptr) &lt;&lt; &quot;\n&quot;;</span><br><span class="line"> </span><br><span class="line">    // 3. 检查写入状态</span><br><span class="line">    if (fout.fail())  </span><br><span class="line">        std::cerr &lt;&lt; &quot;Write failed!&quot;;</span><br><span class="line"> </span><br><span class="line">    // 4. 关闭文件</span><br><span class="line">    fout.close(); </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件常见问题及解决方案"><a href="#文件常见问题及解决方案" class="headerlink" title="文件常见问题及解决方案"></a>文件常见问题及解决方案</h3><blockquote>
<p><strong>1. 检查文件是否成功打开：</strong> 使用 <code>is_open()</code> 成员函数检查文件是否成功打开，如果未成功，则采取相应措施</p>
<p><strong>2. 显式关闭文件：</strong> 尽管C++流对象在析构时会自动关闭文件，显式调用 <code>close()</code> 函数可以提高代码的清晰度和控制力</p>
<p><strong>3. 使用追加或读写模式：</strong> 如果需要在文件末尾追加内容，可以使用 <code>ios::app</code> 模式；如果需要读写同一文件，可以使用 <code>ios::in | ios::out</code> 模式</p>
<p><strong>4. 注意字符编码：</strong> 明确文件的编码格式，必要时使用第三方库处理不同编码的读写</p>
</blockquote>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://gavincarter1991.github.io/2025/07/24/C-%E5%85%A5%E9%97%A8/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E2%80%9CC-%E2%80%9D/" rel="tag">“C++”</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E2%80%9C%E5%85%A5%E9%97%A8%E2%80%9D/" rel="tag">“入门”</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2025/07/29/C-%E8%BF%9B%E9%98%B6/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            C++ 进阶
          
        </div>
      </a>
    
    
      <a href="/2025/07/07/Flutter-%E8%AF%A6%E8%A7%A3%E5%B8%83%E5%B1%80/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Flutter-详解布局</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.staticfile.org/valine/1.4.16/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "a1S86fOlOUpjKlnF6GbDEaXa-gzGzoHsz",
    app_key: "I8KJc5Z8uB7wXwz3r7Mab2Rx",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "留下您的宝贵意见...",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2025
        <i class="ri-heart-fill heart_icon"></i> kindyourself@163.com
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Gavin&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.jianshu.com/u/51707eacf496">简书</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://blog.csdn.net/gavincarter1991/article/list">CSDN</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.png">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>